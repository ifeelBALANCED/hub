/**
 * Generated by orval v7.13.0 üç∫
 * Do not edit manually.
 * Hub API Documentation
 * Production-ready backend for a Google Meet-like video conferencing application
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/vue-query'
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType,
} from '@tanstack/vue-query'

import { computed, unref } from 'vue'
import type { MaybeRef } from 'vue'

import { customInstance } from './mutator/custom-instance'
import type { ErrorType, BodyType } from './mutator/custom-instance'
export interface Error {
  type?: string
  title?: string
  detail?: string
  status?: number
}

export interface UserResponse {
  id?: string
  email?: string
  displayName?: string
  avatarUrl?: string
  createdAt?: string
  updatedAt?: string
}

export interface RegisterRequest {
  email: string
  /** @minLength 8 */
  password: string
  /**
   * @minLength 1
   * @maxLength 255
   */
  displayName: string
}

export interface LoginRequest {
  email: string
  password: string
}

export interface OAuthGoogleRequest {
  idToken: string
}

export interface RefreshTokenRequest {
  refreshToken?: string
}

export interface TokensResponse {
  accessToken?: string
  refreshToken?: string
  accessTokenExpiresIn?: number
  refreshTokenExpiresIn?: number
}

export interface CreateMeetingRequest {
  /** @maxLength 255 */
  title?: string
  scheduledAt?: string
}

export interface MeetingResponse {
  id?: string
  code?: string
  title?: string
  hostId?: string
  scheduledAt?: string
  createdAt?: string
  isActive?: boolean
}

export interface MeetingListResponse {
  meetings?: MeetingResponse[]
}

export interface ResolveCodeRequest {
  /** @pattern ^[a-z]{3}-[a-z]{4}-[a-z]{3}$ */
  code: string
}

export interface RoomTokenRequest {
  allowGuest?: boolean
  displayName?: string
}

export interface RoomTokenResponse {
  roomToken?: string
}

export type CreateInviteRequestRole =
  (typeof CreateInviteRequestRole)[keyof typeof CreateInviteRequestRole]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateInviteRequestRole = {
  guest: 'guest',
  cohost: 'cohost',
} as const

export interface CreateInviteRequest {
  email: string
  role: CreateInviteRequestRole
}

export type InviteResponseRole = (typeof InviteResponseRole)[keyof typeof InviteResponseRole]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InviteResponseRole = {
  guest: 'guest',
  cohost: 'cohost',
} as const

export type InviteResponseStatus = (typeof InviteResponseStatus)[keyof typeof InviteResponseStatus]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InviteResponseStatus = {
  pending: 'pending',
  accepted: 'accepted',
  declined: 'declined',
} as const

export interface InviteResponse {
  id?: string
  meetingId?: string
  email?: string
  role?: InviteResponseRole
  status?: InviteResponseStatus
  createdAt?: string
  expiresAt?: string
}

export interface InviteListResponse {
  invites?: InviteResponse[]
}

export interface UpdateProfileRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  displayName?: string
  avatarUrl?: string
}

export interface SuccessResponse {
  success?: boolean
}

export type Get200 = {
  success?: boolean
  message?: string
  version?: string
  timestamp?: string
  docs?: string
  swagger?: string
}

export type PostV1AuthRefresh200 = {
  accessToken?: string
  accessTokenExpiresIn?: number
}

export type GetV1AuthMe200 = {
  user?: UserResponse
}

export type GetV1MeetingsParams = {
  /**
   * Filter to show only upcoming meetings
   */
  upcoming?: boolean
  /**
   * Maximum number of meetings to return
   * @minimum 1
   * @maximum 100
   */
  limit?: number
}

export type PatchV1Me200 = {
  user?: UserResponse
}

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Check if the API is running
 * @summary API Status
 */
export const get = (options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
  return customInstance<Get200>({ url: `/`, method: 'GET', signal }, options)
}

export const getGetQueryKey = () => {
  return [] as const
}

export const getGetQueryOptions = <
  TData = Awaited<ReturnType<typeof get>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) =>
    get(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof get>>,
    TError,
    TData
  >
}

export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>
export type GetQueryError = ErrorType<unknown>

/**
 * @summary API Status
 */

export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = ErrorType<unknown>>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Create a new user account with email and password
 * @summary Register a new user
 */
export const postV1AuthRegister = (
  registerRequest: MaybeRef<RegisterRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  registerRequest = unref(registerRequest)

  return customInstance<TokensResponse>(
    {
      url: `/v1/auth/register`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: registerRequest,
      signal,
    },
    options,
  )
}

export const getPostV1AuthRegisterMutationOptions = <
  TError = ErrorType<Error | Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1AuthRegister>>,
    TError,
    { data: BodyType<RegisterRequest> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1AuthRegister>>,
  TError,
  { data: BodyType<RegisterRequest> },
  TContext
> => {
  const mutationKey = ['postV1AuthRegister']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1AuthRegister>>,
    { data: BodyType<RegisterRequest> }
  > = (props) => {
    const { data } = props ?? {}

    return postV1AuthRegister(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1AuthRegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1AuthRegister>>
>
export type PostV1AuthRegisterMutationBody = BodyType<RegisterRequest>
export type PostV1AuthRegisterMutationError = ErrorType<Error | Error>

/**
 * @summary Register a new user
 */
export const usePostV1AuthRegister = <TError = ErrorType<Error | Error>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1AuthRegister>>,
      TError,
      { data: BodyType<RegisterRequest> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1AuthRegister>>,
  TError,
  { data: BodyType<RegisterRequest> },
  TContext
> => {
  const mutationOptions = getPostV1AuthRegisterMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Authenticate user and return access and refresh tokens
 * @summary Login with email and password
 */
export const postV1AuthLogin = (
  loginRequest: MaybeRef<LoginRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  loginRequest = unref(loginRequest)

  return customInstance<TokensResponse>(
    {
      url: `/v1/auth/login`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: loginRequest,
      signal,
    },
    options,
  )
}

export const getPostV1AuthLoginMutationOptions = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1AuthLogin>>,
    TError,
    { data: BodyType<LoginRequest> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1AuthLogin>>,
  TError,
  { data: BodyType<LoginRequest> },
  TContext
> => {
  const mutationKey = ['postV1AuthLogin']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1AuthLogin>>,
    { data: BodyType<LoginRequest> }
  > = (props) => {
    const { data } = props ?? {}

    return postV1AuthLogin(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1AuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AuthLogin>>>
export type PostV1AuthLoginMutationBody = BodyType<LoginRequest>
export type PostV1AuthLoginMutationError = ErrorType<Error>

/**
 * @summary Login with email and password
 */
export const usePostV1AuthLogin = <TError = ErrorType<Error>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1AuthLogin>>,
      TError,
      { data: BodyType<LoginRequest> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1AuthLogin>>,
  TError,
  { data: BodyType<LoginRequest> },
  TContext
> => {
  const mutationOptions = getPostV1AuthLoginMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Authenticate user using Google OAuth ID token
 * @summary OAuth login with Google
 */
export const postV1AuthOauthGoogle = (
  oAuthGoogleRequest: MaybeRef<OAuthGoogleRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  oAuthGoogleRequest = unref(oAuthGoogleRequest)

  return customInstance<TokensResponse>(
    {
      url: `/v1/auth/oauth/google`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: oAuthGoogleRequest,
      signal,
    },
    options,
  )
}

export const getPostV1AuthOauthGoogleMutationOptions = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1AuthOauthGoogle>>,
    TError,
    { data: BodyType<OAuthGoogleRequest> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1AuthOauthGoogle>>,
  TError,
  { data: BodyType<OAuthGoogleRequest> },
  TContext
> => {
  const mutationKey = ['postV1AuthOauthGoogle']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1AuthOauthGoogle>>,
    { data: BodyType<OAuthGoogleRequest> }
  > = (props) => {
    const { data } = props ?? {}

    return postV1AuthOauthGoogle(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1AuthOauthGoogleMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1AuthOauthGoogle>>
>
export type PostV1AuthOauthGoogleMutationBody = BodyType<OAuthGoogleRequest>
export type PostV1AuthOauthGoogleMutationError = ErrorType<Error>

/**
 * @summary OAuth login with Google
 */
export const usePostV1AuthOauthGoogle = <TError = ErrorType<Error>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1AuthOauthGoogle>>,
      TError,
      { data: BodyType<OAuthGoogleRequest> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1AuthOauthGoogle>>,
  TError,
  { data: BodyType<OAuthGoogleRequest> },
  TContext
> => {
  const mutationOptions = getPostV1AuthOauthGoogleMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get a new access token using refresh token
 * @summary Refresh access token
 */
export const postV1AuthRefresh = (
  refreshTokenRequest: MaybeRef<RefreshTokenRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  refreshTokenRequest = unref(refreshTokenRequest)

  return customInstance<PostV1AuthRefresh200>(
    {
      url: `/v1/auth/refresh`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: refreshTokenRequest,
      signal,
    },
    options,
  )
}

export const getPostV1AuthRefreshMutationOptions = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1AuthRefresh>>,
    TError,
    { data: BodyType<RefreshTokenRequest> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1AuthRefresh>>,
  TError,
  { data: BodyType<RefreshTokenRequest> },
  TContext
> => {
  const mutationKey = ['postV1AuthRefresh']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1AuthRefresh>>,
    { data: BodyType<RefreshTokenRequest> }
  > = (props) => {
    const { data } = props ?? {}

    return postV1AuthRefresh(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1AuthRefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1AuthRefresh>>
>
export type PostV1AuthRefreshMutationBody = BodyType<RefreshTokenRequest>
export type PostV1AuthRefreshMutationError = ErrorType<Error>

/**
 * @summary Refresh access token
 */
export const usePostV1AuthRefresh = <TError = ErrorType<Error>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1AuthRefresh>>,
      TError,
      { data: BodyType<RefreshTokenRequest> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1AuthRefresh>>,
  TError,
  { data: BodyType<RefreshTokenRequest> },
  TContext
> => {
  const mutationOptions = getPostV1AuthRefreshMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Invalidate the current refresh token
 * @summary Logout user
 */
export const postV1AuthLogout = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SuccessResponse>(
    { url: `/v1/auth/logout`, method: 'POST', signal },
    options,
  )
}

export const getPostV1AuthLogoutMutationOptions = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1AuthLogout>>,
    TError,
    void,
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof postV1AuthLogout>>, TError, void, TContext> => {
  const mutationKey = ['postV1AuthLogout']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AuthLogout>>, void> = () => {
    return postV1AuthLogout(requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1AuthLogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1AuthLogout>>
>

export type PostV1AuthLogoutMutationError = ErrorType<Error>

/**
 * @summary Logout user
 */
export const usePostV1AuthLogout = <TError = ErrorType<Error>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1AuthLogout>>,
      TError,
      void,
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<Awaited<ReturnType<typeof postV1AuthLogout>>, TError, void, TContext> => {
  const mutationOptions = getPostV1AuthLogoutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get the profile information of the currently authenticated user
 * @summary Get current user
 */
export const getV1AuthMe = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetV1AuthMe200>({ url: `/v1/auth/me`, method: 'GET', signal }, options)
}

export const getGetV1AuthMeQueryKey = () => {
  return ['v1', 'auth', 'me'] as const
}

export const getGetV1AuthMeQueryOptions = <
  TData = Awaited<ReturnType<typeof getV1AuthMe>>,
  TError = ErrorType<Error>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthMe>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetV1AuthMeQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AuthMe>>> = ({ signal }) =>
    getV1AuthMe(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getV1AuthMe>>,
    TError,
    TData
  >
}

export type GetV1AuthMeQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AuthMe>>>
export type GetV1AuthMeQueryError = ErrorType<Error>

/**
 * @summary Get current user
 */

export function useGetV1AuthMe<
  TData = Awaited<ReturnType<typeof getV1AuthMe>>,
  TError = ErrorType<Error>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthMe>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1AuthMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Create a new meeting with a unique code and set the creator as host
 * @summary Create a new meeting
 */
export const postV1Meetings = (
  createMeetingRequest: MaybeRef<CreateMeetingRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  createMeetingRequest = unref(createMeetingRequest)

  return customInstance<MeetingResponse>(
    {
      url: `/v1/meetings/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createMeetingRequest,
      signal,
    },
    options,
  )
}

export const getPostV1MeetingsMutationOptions = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1Meetings>>,
    TError,
    { data: BodyType<CreateMeetingRequest> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1Meetings>>,
  TError,
  { data: BodyType<CreateMeetingRequest> },
  TContext
> => {
  const mutationKey = ['postV1Meetings']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1Meetings>>,
    { data: BodyType<CreateMeetingRequest> }
  > = (props) => {
    const { data } = props ?? {}

    return postV1Meetings(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1MeetingsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1Meetings>>>
export type PostV1MeetingsMutationBody = BodyType<CreateMeetingRequest>
export type PostV1MeetingsMutationError = ErrorType<Error>

/**
 * @summary Create a new meeting
 */
export const usePostV1Meetings = <TError = ErrorType<Error>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1Meetings>>,
      TError,
      { data: BodyType<CreateMeetingRequest> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1Meetings>>,
  TError,
  { data: BodyType<CreateMeetingRequest> },
  TContext
> => {
  const mutationOptions = getPostV1MeetingsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get meetings where the authenticated user is host or participant
 * @summary List user meetings
 */
export const getV1Meetings = (
  params?: MaybeRef<GetV1MeetingsParams>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  params = unref(params)

  return customInstance<MeetingListResponse>(
    { url: `/v1/meetings/`, method: 'GET', params: unref(params), signal },
    options,
  )
}

export const getGetV1MeetingsQueryKey = (params?: MaybeRef<GetV1MeetingsParams>) => {
  return ['v1', 'meetings', ...(params ? [params] : [])] as const
}

export const getGetV1MeetingsQueryOptions = <
  TData = Awaited<ReturnType<typeof getV1Meetings>>,
  TError = ErrorType<Error>,
>(
  params?: MaybeRef<GetV1MeetingsParams>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Meetings>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetV1MeetingsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1Meetings>>> = ({ signal }) =>
    getV1Meetings(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getV1Meetings>>,
    TError,
    TData
  >
}

export type GetV1MeetingsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1Meetings>>>
export type GetV1MeetingsQueryError = ErrorType<Error>

/**
 * @summary List user meetings
 */

export function useGetV1Meetings<
  TData = Awaited<ReturnType<typeof getV1Meetings>>,
  TError = ErrorType<Error>,
>(
  params?: MaybeRef<GetV1MeetingsParams>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Meetings>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1MeetingsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Get detailed information about a specific meeting
 * @summary Get meeting details
 */
export const getV1MeetingsId = (
  id: MaybeRef<string>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  id = unref(id)

  return customInstance<MeetingResponse>(
    { url: `/v1/meetings/${id}`, method: 'GET', signal },
    options,
  )
}

export const getGetV1MeetingsIdQueryKey = (id?: MaybeRef<string>) => {
  return ['v1', 'meetings', id] as const
}

export const getGetV1MeetingsIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getV1MeetingsId>>,
  TError = ErrorType<Error | Error | Error>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1MeetingsId>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetV1MeetingsIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1MeetingsId>>> = ({ signal }) =>
    getV1MeetingsId(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getV1MeetingsId>>, TError, TData>
}

export type GetV1MeetingsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1MeetingsId>>>
export type GetV1MeetingsIdQueryError = ErrorType<Error | Error | Error>

/**
 * @summary Get meeting details
 */

export function useGetV1MeetingsId<
  TData = Awaited<ReturnType<typeof getV1MeetingsId>>,
  TError = ErrorType<Error | Error | Error>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1MeetingsId>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1MeetingsIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Convert a meeting code to the corresponding meeting ID
 * @summary Resolve meeting code
 */
export const postV1MeetingsResolveCode = (
  resolveCodeRequest: MaybeRef<ResolveCodeRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  resolveCodeRequest = unref(resolveCodeRequest)

  return customInstance<MeetingResponse>(
    {
      url: `/v1/meetings/resolve-code`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: resolveCodeRequest,
      signal,
    },
    options,
  )
}

export const getPostV1MeetingsResolveCodeMutationOptions = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1MeetingsResolveCode>>,
    TError,
    { data: BodyType<ResolveCodeRequest> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1MeetingsResolveCode>>,
  TError,
  { data: BodyType<ResolveCodeRequest> },
  TContext
> => {
  const mutationKey = ['postV1MeetingsResolveCode']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1MeetingsResolveCode>>,
    { data: BodyType<ResolveCodeRequest> }
  > = (props) => {
    const { data } = props ?? {}

    return postV1MeetingsResolveCode(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1MeetingsResolveCodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1MeetingsResolveCode>>
>
export type PostV1MeetingsResolveCodeMutationBody = BodyType<ResolveCodeRequest>
export type PostV1MeetingsResolveCodeMutationError = ErrorType<Error>

/**
 * @summary Resolve meeting code
 */
export const usePostV1MeetingsResolveCode = <TError = ErrorType<Error>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1MeetingsResolveCode>>,
      TError,
      { data: BodyType<ResolveCodeRequest> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1MeetingsResolveCode>>,
  TError,
  { data: BodyType<ResolveCodeRequest> },
  TContext
> => {
  const mutationOptions = getPostV1MeetingsResolveCodeMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Generate a short-lived JWT token for joining the meeting room
 * @summary Get room token
 */
export const postV1MeetingsIdRoomToken = (
  id: MaybeRef<string>,
  roomTokenRequest: MaybeRef<RoomTokenRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  id = unref(id)
  roomTokenRequest = unref(roomTokenRequest)

  return customInstance<RoomTokenResponse>(
    {
      url: `/v1/meetings/${id}/room-token`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: roomTokenRequest,
      signal,
    },
    options,
  )
}

export const getPostV1MeetingsIdRoomTokenMutationOptions = <
  TError = ErrorType<Error | Error | Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1MeetingsIdRoomToken>>,
    TError,
    { id: string; data: BodyType<RoomTokenRequest> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1MeetingsIdRoomToken>>,
  TError,
  { id: string; data: BodyType<RoomTokenRequest> },
  TContext
> => {
  const mutationKey = ['postV1MeetingsIdRoomToken']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1MeetingsIdRoomToken>>,
    { id: string; data: BodyType<RoomTokenRequest> }
  > = (props) => {
    const { id, data } = props ?? {}

    return postV1MeetingsIdRoomToken(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1MeetingsIdRoomTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1MeetingsIdRoomToken>>
>
export type PostV1MeetingsIdRoomTokenMutationBody = BodyType<RoomTokenRequest>
export type PostV1MeetingsIdRoomTokenMutationError = ErrorType<Error | Error | Error>

/**
 * @summary Get room token
 */
export const usePostV1MeetingsIdRoomToken = <
  TError = ErrorType<Error | Error | Error>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1MeetingsIdRoomToken>>,
      TError,
      { id: string; data: BodyType<RoomTokenRequest> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1MeetingsIdRoomToken>>,
  TError,
  { id: string; data: BodyType<RoomTokenRequest> },
  TContext
> => {
  const mutationOptions = getPostV1MeetingsIdRoomTokenMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Send an invitation to a user to join the meeting
 * @summary Create meeting invite
 */
export const postV1MeetingsIdInvites = (
  id: MaybeRef<string>,
  createInviteRequest: MaybeRef<CreateInviteRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  id = unref(id)
  createInviteRequest = unref(createInviteRequest)

  return customInstance<InviteResponse>(
    {
      url: `/v1/meetings/${id}/invites`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createInviteRequest,
      signal,
    },
    options,
  )
}

export const getPostV1MeetingsIdInvitesMutationOptions = <
  TError = ErrorType<Error | Error | Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1MeetingsIdInvites>>,
    TError,
    { id: string; data: BodyType<CreateInviteRequest> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1MeetingsIdInvites>>,
  TError,
  { id: string; data: BodyType<CreateInviteRequest> },
  TContext
> => {
  const mutationKey = ['postV1MeetingsIdInvites']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1MeetingsIdInvites>>,
    { id: string; data: BodyType<CreateInviteRequest> }
  > = (props) => {
    const { id, data } = props ?? {}

    return postV1MeetingsIdInvites(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1MeetingsIdInvitesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1MeetingsIdInvites>>
>
export type PostV1MeetingsIdInvitesMutationBody = BodyType<CreateInviteRequest>
export type PostV1MeetingsIdInvitesMutationError = ErrorType<Error | Error | Error>

/**
 * @summary Create meeting invite
 */
export const usePostV1MeetingsIdInvites = <
  TError = ErrorType<Error | Error | Error>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1MeetingsIdInvites>>,
      TError,
      { id: string; data: BodyType<CreateInviteRequest> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1MeetingsIdInvites>>,
  TError,
  { id: string; data: BodyType<CreateInviteRequest> },
  TContext
> => {
  const mutationOptions = getPostV1MeetingsIdInvitesMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Retrieve all pending and processed invitations for a specific meeting
 * @summary List meeting invites
 */
export const getV1MeetingsIdInvites = (
  id: MaybeRef<string>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  id = unref(id)

  return customInstance<InviteListResponse>(
    { url: `/v1/meetings/${id}/invites`, method: 'GET', signal },
    options,
  )
}

export const getGetV1MeetingsIdInvitesQueryKey = (id?: MaybeRef<string>) => {
  return ['v1', 'meetings', id, 'invites'] as const
}

export const getGetV1MeetingsIdInvitesQueryOptions = <
  TData = Awaited<ReturnType<typeof getV1MeetingsIdInvites>>,
  TError = ErrorType<Error | Error | Error>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1MeetingsIdInvites>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetV1MeetingsIdInvitesQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1MeetingsIdInvites>>> = ({ signal }) =>
    getV1MeetingsIdInvites(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getV1MeetingsIdInvites>>, TError, TData>
}

export type GetV1MeetingsIdInvitesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getV1MeetingsIdInvites>>
>
export type GetV1MeetingsIdInvitesQueryError = ErrorType<Error | Error | Error>

/**
 * @summary List meeting invites
 */

export function useGetV1MeetingsIdInvites<
  TData = Awaited<ReturnType<typeof getV1MeetingsIdInvites>>,
  TError = ErrorType<Error | Error | Error>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1MeetingsIdInvites>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1MeetingsIdInvitesQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Accept a pending meeting invitation
 * @summary Accept invite
 */
export const postV1InvitesInviteIdAccept = (
  inviteId: MaybeRef<string>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  inviteId = unref(inviteId)

  return customInstance<SuccessResponse>(
    { url: `/v1/invites/${inviteId}/accept`, method: 'POST', signal },
    options,
  )
}

export const getPostV1InvitesInviteIdAcceptMutationOptions = <
  TError = ErrorType<Error | Error | Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1InvitesInviteIdAccept>>,
    TError,
    { inviteId: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1InvitesInviteIdAccept>>,
  TError,
  { inviteId: string },
  TContext
> => {
  const mutationKey = ['postV1InvitesInviteIdAccept']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1InvitesInviteIdAccept>>,
    { inviteId: string }
  > = (props) => {
    const { inviteId } = props ?? {}

    return postV1InvitesInviteIdAccept(inviteId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1InvitesInviteIdAcceptMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1InvitesInviteIdAccept>>
>

export type PostV1InvitesInviteIdAcceptMutationError = ErrorType<Error | Error | Error>

/**
 * @summary Accept invite
 */
export const usePostV1InvitesInviteIdAccept = <
  TError = ErrorType<Error | Error | Error>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1InvitesInviteIdAccept>>,
      TError,
      { inviteId: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1InvitesInviteIdAccept>>,
  TError,
  { inviteId: string },
  TContext
> => {
  const mutationOptions = getPostV1InvitesInviteIdAcceptMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Decline a pending meeting invitation
 * @summary Decline invite
 */
export const postV1InvitesInviteIdDecline = (
  inviteId: MaybeRef<string>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  inviteId = unref(inviteId)

  return customInstance<SuccessResponse>(
    { url: `/v1/invites/${inviteId}/decline`, method: 'POST', signal },
    options,
  )
}

export const getPostV1InvitesInviteIdDeclineMutationOptions = <
  TError = ErrorType<Error | Error | Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1InvitesInviteIdDecline>>,
    TError,
    { inviteId: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1InvitesInviteIdDecline>>,
  TError,
  { inviteId: string },
  TContext
> => {
  const mutationKey = ['postV1InvitesInviteIdDecline']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1InvitesInviteIdDecline>>,
    { inviteId: string }
  > = (props) => {
    const { inviteId } = props ?? {}

    return postV1InvitesInviteIdDecline(inviteId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1InvitesInviteIdDeclineMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1InvitesInviteIdDecline>>
>

export type PostV1InvitesInviteIdDeclineMutationError = ErrorType<Error | Error | Error>

/**
 * @summary Decline invite
 */
export const usePostV1InvitesInviteIdDecline = <
  TError = ErrorType<Error | Error | Error>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1InvitesInviteIdDecline>>,
      TError,
      { inviteId: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1InvitesInviteIdDecline>>,
  TError,
  { inviteId: string },
  TContext
> => {
  const mutationOptions = getPostV1InvitesInviteIdDeclineMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Update the profile information of the currently authenticated user
 * @summary Update profile
 */
export const patchV1Me = (
  updateProfileRequest: MaybeRef<UpdateProfileRequest>,
  options?: SecondParameter<typeof customInstance>,
) => {
  updateProfileRequest = unref(updateProfileRequest)

  return customInstance<PatchV1Me200>(
    {
      url: `/v1/me`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateProfileRequest,
    },
    options,
  )
}

export const getPatchV1MeMutationOptions = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchV1Me>>,
    TError,
    { data: BodyType<UpdateProfileRequest> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchV1Me>>,
  TError,
  { data: BodyType<UpdateProfileRequest> },
  TContext
> => {
  const mutationKey = ['patchV1Me']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchV1Me>>,
    { data: BodyType<UpdateProfileRequest> }
  > = (props) => {
    const { data } = props ?? {}

    return patchV1Me(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PatchV1MeMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1Me>>>
export type PatchV1MeMutationBody = BodyType<UpdateProfileRequest>
export type PatchV1MeMutationError = ErrorType<Error>

/**
 * @summary Update profile
 */
export const usePatchV1Me = <TError = ErrorType<Error>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchV1Me>>,
      TError,
      { data: BodyType<UpdateProfileRequest> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof patchV1Me>>,
  TError,
  { data: BodyType<UpdateProfileRequest> },
  TContext
> => {
  const mutationOptions = getPatchV1MeMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
