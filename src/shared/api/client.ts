/**
 * Generated by orval v7.13.0 üç∫
 * Do not edit manually.
 * Hub API Documentation
 * Production-ready backend for a Google Meet-like video conferencing application
 * OpenAPI spec version: 1.0.0
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/vue-query'
import type {
  DataTag,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryReturnType,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType,
} from '@tanstack/vue-query'

import { computed, unref } from 'vue'
import type { MaybeRef } from 'vue'

import { customInstance } from './mutator/custom-instance'
import type { ErrorType, BodyType } from './mutator/custom-instance'
export interface Error {
  type?: string
  title?: string
  detail?: string
  status?: number
}

export interface UserResponse {
  id?: string
  email?: string
  displayName?: string
  avatarUrl?: string
  createdAt?: string
  updatedAt?: string
}

export interface MeetingResponse {
  id?: string
  code?: string
  title?: string
  hostId?: string
  scheduledAt?: string
  createdAt?: string
  isActive?: boolean
}

export interface TokensResponse {
  accessToken?: string
  refreshToken?: string
  accessTokenExpiresIn?: number
  refreshTokenExpiresIn?: number
}

export type Get200 = {
  success?: boolean
  message?: string
  version?: string
  timestamp?: string
  docs?: string
  swagger?: string
}

export type PostV1AuthRegisterBody = {
  email: string
  /** @minLength 8 */
  password: string
  /**
   * @minLength 1
   * @maxLength 255
   */
  displayName: string
}

export type PostV1AuthRegister201 = {
  accessToken?: string
  refreshToken?: string
  accessTokenExpiresIn?: number
  refreshTokenExpiresIn?: number
}

export type PostV1AuthLoginBody = {
  email: string
  password: string
}

export type PostV1AuthLogin200 = {
  accessToken?: string
  refreshToken?: string
  accessTokenExpiresIn?: number
  refreshTokenExpiresIn?: number
}

export type PostV1AuthOauthGoogleBody = {
  idToken: string
}

export type PostV1AuthRefreshBody = {
  refreshToken?: string
}

export type PostV1MeetingsBody = {
  /** @maxLength 255 */
  title?: string
  scheduledAt?: string
}

export type GetV1MeetingsParams = {
  /**
   * Filter to show only upcoming meetings
   */
  upcoming?: boolean
  /**
   * Maximum number of meetings to return
   * @minimum 1
   * @maximum 100
   */
  limit?: number
}

export type PostV1MeetingsResolveCodeBody = {
  /** @pattern ^[a-z]{3}-[a-z]{4}-[a-z]{3}$ */
  code: string
}

export type PostV1MeetingsIdRoomTokenBody = {
  allowGuest?: boolean
  displayName?: string
}

export type PostV1MeetingsIdInvitesBodyRole =
  (typeof PostV1MeetingsIdInvitesBodyRole)[keyof typeof PostV1MeetingsIdInvitesBodyRole]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostV1MeetingsIdInvitesBodyRole = {
  guest: 'guest',
  cohost: 'cohost',
} as const

export type PostV1MeetingsIdInvitesBody = {
  email: string
  role: PostV1MeetingsIdInvitesBodyRole
}

export type PatchV1MeBody = {
  /**
   * @minLength 1
   * @maxLength 255
   */
  displayName?: string
  avatarUrl?: string
}

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Check if the API is running
 * @summary API Status
 */
export const get = (options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
  return customInstance<Get200>({ url: `/`, method: 'GET', signal }, options)
}

export const getGetQueryKey = () => {
  return [] as const
}

export const getGetInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof get>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) =>
    get(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof get>>,
    TError,
    TData
  >
}

export type GetInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>
export type GetInfiniteQueryError = ErrorType<unknown>

/**
 * @summary API Status
 */

export function useGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof get>>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

export const getGetQueryOptions = <
  TData = Awaited<ReturnType<typeof get>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) =>
    get(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof get>>,
    TError,
    TData
  >
}

export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>
export type GetQueryError = ErrorType<unknown>

/**
 * @summary API Status
 */

export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = ErrorType<unknown>>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Create a new user account with email and password
 * @summary Register a new user
 */
export const postV1AuthRegister = (
  postV1AuthRegisterBody: MaybeRef<PostV1AuthRegisterBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  postV1AuthRegisterBody = unref(postV1AuthRegisterBody)

  return customInstance<PostV1AuthRegister201>(
    {
      url: `/v1/auth/register`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: postV1AuthRegisterBody,
      signal,
    },
    options,
  )
}

export const getPostV1AuthRegisterMutationOptions = <
  TError = ErrorType<void | void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1AuthRegister>>,
    TError,
    { data: BodyType<PostV1AuthRegisterBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1AuthRegister>>,
  TError,
  { data: BodyType<PostV1AuthRegisterBody> },
  TContext
> => {
  const mutationKey = ['postV1AuthRegister']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1AuthRegister>>,
    { data: BodyType<PostV1AuthRegisterBody> }
  > = (props) => {
    const { data } = props ?? {}

    return postV1AuthRegister(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1AuthRegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1AuthRegister>>
>
export type PostV1AuthRegisterMutationBody = BodyType<PostV1AuthRegisterBody>
export type PostV1AuthRegisterMutationError = ErrorType<void | void>

/**
 * @summary Register a new user
 */
export const usePostV1AuthRegister = <TError = ErrorType<void | void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1AuthRegister>>,
      TError,
      { data: BodyType<PostV1AuthRegisterBody> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1AuthRegister>>,
  TError,
  { data: BodyType<PostV1AuthRegisterBody> },
  TContext
> => {
  const mutationOptions = getPostV1AuthRegisterMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Authenticate user and return access and refresh tokens
 * @summary Login with email and password
 */
export const postV1AuthLogin = (
  postV1AuthLoginBody: MaybeRef<PostV1AuthLoginBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  postV1AuthLoginBody = unref(postV1AuthLoginBody)

  return customInstance<PostV1AuthLogin200>(
    {
      url: `/v1/auth/login`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: postV1AuthLoginBody,
      signal,
    },
    options,
  )
}

export const getPostV1AuthLoginMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1AuthLogin>>,
    TError,
    { data: BodyType<PostV1AuthLoginBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1AuthLogin>>,
  TError,
  { data: BodyType<PostV1AuthLoginBody> },
  TContext
> => {
  const mutationKey = ['postV1AuthLogin']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1AuthLogin>>,
    { data: BodyType<PostV1AuthLoginBody> }
  > = (props) => {
    const { data } = props ?? {}

    return postV1AuthLogin(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1AuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AuthLogin>>>
export type PostV1AuthLoginMutationBody = BodyType<PostV1AuthLoginBody>
export type PostV1AuthLoginMutationError = ErrorType<void>

/**
 * @summary Login with email and password
 */
export const usePostV1AuthLogin = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1AuthLogin>>,
      TError,
      { data: BodyType<PostV1AuthLoginBody> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1AuthLogin>>,
  TError,
  { data: BodyType<PostV1AuthLoginBody> },
  TContext
> => {
  const mutationOptions = getPostV1AuthLoginMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Authenticate user using Google OAuth ID token
 * @summary OAuth login with Google
 */
export const postV1AuthOauthGoogle = (
  postV1AuthOauthGoogleBody: MaybeRef<PostV1AuthOauthGoogleBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  postV1AuthOauthGoogleBody = unref(postV1AuthOauthGoogleBody)

  return customInstance<void>(
    {
      url: `/v1/auth/oauth/google`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: postV1AuthOauthGoogleBody,
      signal,
    },
    options,
  )
}

export const getPostV1AuthOauthGoogleMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1AuthOauthGoogle>>,
    TError,
    { data: BodyType<PostV1AuthOauthGoogleBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1AuthOauthGoogle>>,
  TError,
  { data: BodyType<PostV1AuthOauthGoogleBody> },
  TContext
> => {
  const mutationKey = ['postV1AuthOauthGoogle']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1AuthOauthGoogle>>,
    { data: BodyType<PostV1AuthOauthGoogleBody> }
  > = (props) => {
    const { data } = props ?? {}

    return postV1AuthOauthGoogle(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1AuthOauthGoogleMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1AuthOauthGoogle>>
>
export type PostV1AuthOauthGoogleMutationBody = BodyType<PostV1AuthOauthGoogleBody>
export type PostV1AuthOauthGoogleMutationError = ErrorType<void>

/**
 * @summary OAuth login with Google
 */
export const usePostV1AuthOauthGoogle = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1AuthOauthGoogle>>,
      TError,
      { data: BodyType<PostV1AuthOauthGoogleBody> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1AuthOauthGoogle>>,
  TError,
  { data: BodyType<PostV1AuthOauthGoogleBody> },
  TContext
> => {
  const mutationOptions = getPostV1AuthOauthGoogleMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get a new access token using refresh token
 * @summary Refresh access token
 */
export const postV1AuthRefresh = (
  postV1AuthRefreshBody: MaybeRef<PostV1AuthRefreshBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  postV1AuthRefreshBody = unref(postV1AuthRefreshBody)

  return customInstance<void>(
    {
      url: `/v1/auth/refresh`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: postV1AuthRefreshBody,
      signal,
    },
    options,
  )
}

export const getPostV1AuthRefreshMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1AuthRefresh>>,
    TError,
    { data: BodyType<PostV1AuthRefreshBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1AuthRefresh>>,
  TError,
  { data: BodyType<PostV1AuthRefreshBody> },
  TContext
> => {
  const mutationKey = ['postV1AuthRefresh']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1AuthRefresh>>,
    { data: BodyType<PostV1AuthRefreshBody> }
  > = (props) => {
    const { data } = props ?? {}

    return postV1AuthRefresh(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1AuthRefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1AuthRefresh>>
>
export type PostV1AuthRefreshMutationBody = BodyType<PostV1AuthRefreshBody>
export type PostV1AuthRefreshMutationError = ErrorType<void>

/**
 * @summary Refresh access token
 */
export const usePostV1AuthRefresh = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1AuthRefresh>>,
      TError,
      { data: BodyType<PostV1AuthRefreshBody> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1AuthRefresh>>,
  TError,
  { data: BodyType<PostV1AuthRefreshBody> },
  TContext
> => {
  const mutationOptions = getPostV1AuthRefreshMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Invalidate the current refresh token
 * @summary Logout user
 */
export const postV1AuthLogout = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>({ url: `/v1/auth/logout`, method: 'POST', signal }, options)
}

export const getPostV1AuthLogoutMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1AuthLogout>>,
    TError,
    void,
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof postV1AuthLogout>>, TError, void, TContext> => {
  const mutationKey = ['postV1AuthLogout']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AuthLogout>>, void> = () => {
    return postV1AuthLogout(requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1AuthLogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1AuthLogout>>
>

export type PostV1AuthLogoutMutationError = ErrorType<void>

/**
 * @summary Logout user
 */
export const usePostV1AuthLogout = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1AuthLogout>>,
      TError,
      void,
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<Awaited<ReturnType<typeof postV1AuthLogout>>, TError, void, TContext> => {
  const mutationOptions = getPostV1AuthLogoutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get the profile information of the currently authenticated user
 * @summary Get current user
 */
export const getV1AuthMe = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>({ url: `/v1/auth/me`, method: 'GET', signal }, options)
}

export const getGetV1AuthMeQueryKey = () => {
  return ['v1', 'auth', 'me'] as const
}

export const getGetV1AuthMeInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getV1AuthMe>>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AuthMe>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetV1AuthMeQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AuthMe>>> = ({ signal }) =>
    getV1AuthMe(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getV1AuthMe>>,
    TError,
    TData
  >
}

export type GetV1AuthMeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AuthMe>>>
export type GetV1AuthMeInfiniteQueryError = ErrorType<void>

/**
 * @summary Get current user
 */

export function useGetV1AuthMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getV1AuthMe>>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AuthMe>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1AuthMeInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

export const getGetV1AuthMeQueryOptions = <
  TData = Awaited<ReturnType<typeof getV1AuthMe>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthMe>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetV1AuthMeQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AuthMe>>> = ({ signal }) =>
    getV1AuthMe(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getV1AuthMe>>,
    TError,
    TData
  >
}

export type GetV1AuthMeQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AuthMe>>>
export type GetV1AuthMeQueryError = ErrorType<void>

/**
 * @summary Get current user
 */

export function useGetV1AuthMe<
  TData = Awaited<ReturnType<typeof getV1AuthMe>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthMe>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1AuthMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Create a new meeting with a unique code and set the creator as host
 * @summary Create a new meeting
 */
export const postV1Meetings = (
  postV1MeetingsBody: MaybeRef<PostV1MeetingsBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  postV1MeetingsBody = unref(postV1MeetingsBody)

  return customInstance<void>(
    {
      url: `/v1/meetings/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: postV1MeetingsBody,
      signal,
    },
    options,
  )
}

export const getPostV1MeetingsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1Meetings>>,
    TError,
    { data: BodyType<PostV1MeetingsBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1Meetings>>,
  TError,
  { data: BodyType<PostV1MeetingsBody> },
  TContext
> => {
  const mutationKey = ['postV1Meetings']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1Meetings>>,
    { data: BodyType<PostV1MeetingsBody> }
  > = (props) => {
    const { data } = props ?? {}

    return postV1Meetings(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1MeetingsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1Meetings>>>
export type PostV1MeetingsMutationBody = BodyType<PostV1MeetingsBody>
export type PostV1MeetingsMutationError = ErrorType<void>

/**
 * @summary Create a new meeting
 */
export const usePostV1Meetings = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1Meetings>>,
      TError,
      { data: BodyType<PostV1MeetingsBody> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1Meetings>>,
  TError,
  { data: BodyType<PostV1MeetingsBody> },
  TContext
> => {
  const mutationOptions = getPostV1MeetingsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get meetings where the authenticated user is host or participant
 * @summary List user meetings
 */
export const getV1Meetings = (
  params?: MaybeRef<GetV1MeetingsParams>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  params = unref(params)

  return customInstance<void>(
    { url: `/v1/meetings/`, method: 'GET', params: unref(params), signal },
    options,
  )
}

export const getGetV1MeetingsQueryKey = (params?: MaybeRef<GetV1MeetingsParams>) => {
  return ['v1', 'meetings', ...(params ? [params] : [])] as const
}

export const getGetV1MeetingsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getV1Meetings>>, GetV1MeetingsParams['nextId']>,
  TError = ErrorType<void>,
>(
  params?: MaybeRef<GetV1MeetingsParams>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getV1Meetings>>,
        TError,
        TData,
        QueryKey,
        GetV1MeetingsParams['nextId']
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetV1MeetingsQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getV1Meetings>>,
    QueryKey,
    GetV1MeetingsParams['nextId']
  > = ({ signal, pageParam }) =>
    getV1Meetings(
      { ...unref(params), nextId: pageParam || unref(params)?.['nextId'] },
      requestOptions,
      signal,
    )

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getV1Meetings>>,
    TError,
    TData,
    QueryKey,
    GetV1MeetingsParams['nextId']
  >
}

export type GetV1MeetingsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getV1Meetings>>
>
export type GetV1MeetingsInfiniteQueryError = ErrorType<void>

/**
 * @summary List user meetings
 */

export function useGetV1MeetingsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getV1Meetings>>, GetV1MeetingsParams['nextId']>,
  TError = ErrorType<void>,
>(
  params?: MaybeRef<GetV1MeetingsParams>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getV1Meetings>>,
        TError,
        TData,
        QueryKey,
        GetV1MeetingsParams['nextId']
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1MeetingsInfiniteQueryOptions(params, options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

export const getGetV1MeetingsQueryOptions = <
  TData = Awaited<ReturnType<typeof getV1Meetings>>,
  TError = ErrorType<void>,
>(
  params?: MaybeRef<GetV1MeetingsParams>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Meetings>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetV1MeetingsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1Meetings>>> = ({ signal }) =>
    getV1Meetings(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getV1Meetings>>,
    TError,
    TData
  >
}

export type GetV1MeetingsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1Meetings>>>
export type GetV1MeetingsQueryError = ErrorType<void>

/**
 * @summary List user meetings
 */

export function useGetV1Meetings<
  TData = Awaited<ReturnType<typeof getV1Meetings>>,
  TError = ErrorType<void>,
>(
  params?: MaybeRef<GetV1MeetingsParams>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Meetings>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1MeetingsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Get detailed information about a specific meeting
 * @summary Get meeting details
 */
export const getV1MeetingsId = (
  id: MaybeRef<string>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  id = unref(id)

  return customInstance<void>({ url: `/v1/meetings/${id}`, method: 'GET', signal }, options)
}

export const getGetV1MeetingsIdQueryKey = (id?: MaybeRef<string>) => {
  return ['v1', 'meetings', id] as const
}

export const getGetV1MeetingsIdInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getV1MeetingsId>>>,
  TError = ErrorType<void | void | void>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1MeetingsId>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetV1MeetingsIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1MeetingsId>>> = ({ signal }) =>
    getV1MeetingsId(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1MeetingsId>>, TError, TData>
}

export type GetV1MeetingsIdInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getV1MeetingsId>>
>
export type GetV1MeetingsIdInfiniteQueryError = ErrorType<void | void | void>

/**
 * @summary Get meeting details
 */

export function useGetV1MeetingsIdInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getV1MeetingsId>>>,
  TError = ErrorType<void | void | void>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1MeetingsId>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1MeetingsIdInfiniteQueryOptions(id, options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

export const getGetV1MeetingsIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getV1MeetingsId>>,
  TError = ErrorType<void | void | void>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1MeetingsId>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetV1MeetingsIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1MeetingsId>>> = ({ signal }) =>
    getV1MeetingsId(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getV1MeetingsId>>, TError, TData>
}

export type GetV1MeetingsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1MeetingsId>>>
export type GetV1MeetingsIdQueryError = ErrorType<void | void | void>

/**
 * @summary Get meeting details
 */

export function useGetV1MeetingsId<
  TData = Awaited<ReturnType<typeof getV1MeetingsId>>,
  TError = ErrorType<void | void | void>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1MeetingsId>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1MeetingsIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Convert a meeting code to the corresponding meeting ID
 * @summary Resolve meeting code
 */
export const postV1MeetingsResolveCode = (
  postV1MeetingsResolveCodeBody: MaybeRef<PostV1MeetingsResolveCodeBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  postV1MeetingsResolveCodeBody = unref(postV1MeetingsResolveCodeBody)

  return customInstance<void>(
    {
      url: `/v1/meetings/resolve-code`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: postV1MeetingsResolveCodeBody,
      signal,
    },
    options,
  )
}

export const getPostV1MeetingsResolveCodeMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1MeetingsResolveCode>>,
    TError,
    { data: BodyType<PostV1MeetingsResolveCodeBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1MeetingsResolveCode>>,
  TError,
  { data: BodyType<PostV1MeetingsResolveCodeBody> },
  TContext
> => {
  const mutationKey = ['postV1MeetingsResolveCode']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1MeetingsResolveCode>>,
    { data: BodyType<PostV1MeetingsResolveCodeBody> }
  > = (props) => {
    const { data } = props ?? {}

    return postV1MeetingsResolveCode(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1MeetingsResolveCodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1MeetingsResolveCode>>
>
export type PostV1MeetingsResolveCodeMutationBody = BodyType<PostV1MeetingsResolveCodeBody>
export type PostV1MeetingsResolveCodeMutationError = ErrorType<void>

/**
 * @summary Resolve meeting code
 */
export const usePostV1MeetingsResolveCode = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1MeetingsResolveCode>>,
      TError,
      { data: BodyType<PostV1MeetingsResolveCodeBody> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1MeetingsResolveCode>>,
  TError,
  { data: BodyType<PostV1MeetingsResolveCodeBody> },
  TContext
> => {
  const mutationOptions = getPostV1MeetingsResolveCodeMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Generate a short-lived JWT token for joining the meeting room
 * @summary Get room token
 */
export const postV1MeetingsIdRoomToken = (
  id: MaybeRef<string>,
  postV1MeetingsIdRoomTokenBody: MaybeRef<PostV1MeetingsIdRoomTokenBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  id = unref(id)
  postV1MeetingsIdRoomTokenBody = unref(postV1MeetingsIdRoomTokenBody)

  return customInstance<void>(
    {
      url: `/v1/meetings/${id}/room-token`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: postV1MeetingsIdRoomTokenBody,
      signal,
    },
    options,
  )
}

export const getPostV1MeetingsIdRoomTokenMutationOptions = <
  TError = ErrorType<void | void | void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1MeetingsIdRoomToken>>,
    TError,
    { id: string; data: BodyType<PostV1MeetingsIdRoomTokenBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1MeetingsIdRoomToken>>,
  TError,
  { id: string; data: BodyType<PostV1MeetingsIdRoomTokenBody> },
  TContext
> => {
  const mutationKey = ['postV1MeetingsIdRoomToken']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1MeetingsIdRoomToken>>,
    { id: string; data: BodyType<PostV1MeetingsIdRoomTokenBody> }
  > = (props) => {
    const { id, data } = props ?? {}

    return postV1MeetingsIdRoomToken(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1MeetingsIdRoomTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1MeetingsIdRoomToken>>
>
export type PostV1MeetingsIdRoomTokenMutationBody = BodyType<PostV1MeetingsIdRoomTokenBody>
export type PostV1MeetingsIdRoomTokenMutationError = ErrorType<void | void | void>

/**
 * @summary Get room token
 */
export const usePostV1MeetingsIdRoomToken = <
  TError = ErrorType<void | void | void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1MeetingsIdRoomToken>>,
      TError,
      { id: string; data: BodyType<PostV1MeetingsIdRoomTokenBody> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1MeetingsIdRoomToken>>,
  TError,
  { id: string; data: BodyType<PostV1MeetingsIdRoomTokenBody> },
  TContext
> => {
  const mutationOptions = getPostV1MeetingsIdRoomTokenMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Send an invitation to a user to join the meeting
 * @summary Create meeting invite
 */
export const postV1MeetingsIdInvites = (
  id: MaybeRef<string>,
  postV1MeetingsIdInvitesBody: MaybeRef<PostV1MeetingsIdInvitesBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  id = unref(id)
  postV1MeetingsIdInvitesBody = unref(postV1MeetingsIdInvitesBody)

  return customInstance<void>(
    {
      url: `/v1/meetings/${id}/invites`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: postV1MeetingsIdInvitesBody,
      signal,
    },
    options,
  )
}

export const getPostV1MeetingsIdInvitesMutationOptions = <
  TError = ErrorType<void | void | void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1MeetingsIdInvites>>,
    TError,
    { id: string; data: BodyType<PostV1MeetingsIdInvitesBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1MeetingsIdInvites>>,
  TError,
  { id: string; data: BodyType<PostV1MeetingsIdInvitesBody> },
  TContext
> => {
  const mutationKey = ['postV1MeetingsIdInvites']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1MeetingsIdInvites>>,
    { id: string; data: BodyType<PostV1MeetingsIdInvitesBody> }
  > = (props) => {
    const { id, data } = props ?? {}

    return postV1MeetingsIdInvites(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1MeetingsIdInvitesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1MeetingsIdInvites>>
>
export type PostV1MeetingsIdInvitesMutationBody = BodyType<PostV1MeetingsIdInvitesBody>
export type PostV1MeetingsIdInvitesMutationError = ErrorType<void | void | void>

/**
 * @summary Create meeting invite
 */
export const usePostV1MeetingsIdInvites = <
  TError = ErrorType<void | void | void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1MeetingsIdInvites>>,
      TError,
      { id: string; data: BodyType<PostV1MeetingsIdInvitesBody> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1MeetingsIdInvites>>,
  TError,
  { id: string; data: BodyType<PostV1MeetingsIdInvitesBody> },
  TContext
> => {
  const mutationOptions = getPostV1MeetingsIdInvitesMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Retrieve all pending and processed invitations for a specific meeting
 * @summary List meeting invites
 */
export const getV1MeetingsIdInvites = (
  id: MaybeRef<string>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  id = unref(id)

  return customInstance<void>({ url: `/v1/meetings/${id}/invites`, method: 'GET', signal }, options)
}

export const getGetV1MeetingsIdInvitesQueryKey = (id?: MaybeRef<string>) => {
  return ['v1', 'meetings', id, 'invites'] as const
}

export const getGetV1MeetingsIdInvitesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getV1MeetingsIdInvites>>>,
  TError = ErrorType<void | void | void>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1MeetingsIdInvites>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetV1MeetingsIdInvitesQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1MeetingsIdInvites>>> = ({ signal }) =>
    getV1MeetingsIdInvites(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1MeetingsIdInvites>>, TError, TData>
}

export type GetV1MeetingsIdInvitesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getV1MeetingsIdInvites>>
>
export type GetV1MeetingsIdInvitesInfiniteQueryError = ErrorType<void | void | void>

/**
 * @summary List meeting invites
 */

export function useGetV1MeetingsIdInvitesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getV1MeetingsIdInvites>>>,
  TError = ErrorType<void | void | void>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1MeetingsIdInvites>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1MeetingsIdInvitesInfiniteQueryOptions(id, options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

export const getGetV1MeetingsIdInvitesQueryOptions = <
  TData = Awaited<ReturnType<typeof getV1MeetingsIdInvites>>,
  TError = ErrorType<void | void | void>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1MeetingsIdInvites>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetV1MeetingsIdInvitesQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1MeetingsIdInvites>>> = ({ signal }) =>
    getV1MeetingsIdInvites(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getV1MeetingsIdInvites>>, TError, TData>
}

export type GetV1MeetingsIdInvitesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getV1MeetingsIdInvites>>
>
export type GetV1MeetingsIdInvitesQueryError = ErrorType<void | void | void>

/**
 * @summary List meeting invites
 */

export function useGetV1MeetingsIdInvites<
  TData = Awaited<ReturnType<typeof getV1MeetingsIdInvites>>,
  TError = ErrorType<void | void | void>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1MeetingsIdInvites>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1MeetingsIdInvitesQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Accept a pending meeting invitation
 * @summary Accept invite
 */
export const postV1InvitesInviteIdAccept = (
  inviteId: MaybeRef<string>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  inviteId = unref(inviteId)

  return customInstance<void>(
    { url: `/v1/invites/${inviteId}/accept`, method: 'POST', signal },
    options,
  )
}

export const getPostV1InvitesInviteIdAcceptMutationOptions = <
  TError = ErrorType<void | void | void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1InvitesInviteIdAccept>>,
    TError,
    { inviteId: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1InvitesInviteIdAccept>>,
  TError,
  { inviteId: string },
  TContext
> => {
  const mutationKey = ['postV1InvitesInviteIdAccept']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1InvitesInviteIdAccept>>,
    { inviteId: string }
  > = (props) => {
    const { inviteId } = props ?? {}

    return postV1InvitesInviteIdAccept(inviteId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1InvitesInviteIdAcceptMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1InvitesInviteIdAccept>>
>

export type PostV1InvitesInviteIdAcceptMutationError = ErrorType<void | void | void>

/**
 * @summary Accept invite
 */
export const usePostV1InvitesInviteIdAccept = <
  TError = ErrorType<void | void | void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1InvitesInviteIdAccept>>,
      TError,
      { inviteId: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1InvitesInviteIdAccept>>,
  TError,
  { inviteId: string },
  TContext
> => {
  const mutationOptions = getPostV1InvitesInviteIdAcceptMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Decline a pending meeting invitation
 * @summary Decline invite
 */
export const postV1InvitesInviteIdDecline = (
  inviteId: MaybeRef<string>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  inviteId = unref(inviteId)

  return customInstance<void>(
    { url: `/v1/invites/${inviteId}/decline`, method: 'POST', signal },
    options,
  )
}

export const getPostV1InvitesInviteIdDeclineMutationOptions = <
  TError = ErrorType<void | void | void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1InvitesInviteIdDecline>>,
    TError,
    { inviteId: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1InvitesInviteIdDecline>>,
  TError,
  { inviteId: string },
  TContext
> => {
  const mutationKey = ['postV1InvitesInviteIdDecline']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1InvitesInviteIdDecline>>,
    { inviteId: string }
  > = (props) => {
    const { inviteId } = props ?? {}

    return postV1InvitesInviteIdDecline(inviteId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostV1InvitesInviteIdDeclineMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1InvitesInviteIdDecline>>
>

export type PostV1InvitesInviteIdDeclineMutationError = ErrorType<void | void | void>

/**
 * @summary Decline invite
 */
export const usePostV1InvitesInviteIdDecline = <
  TError = ErrorType<void | void | void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1InvitesInviteIdDecline>>,
      TError,
      { inviteId: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postV1InvitesInviteIdDecline>>,
  TError,
  { inviteId: string },
  TContext
> => {
  const mutationOptions = getPostV1InvitesInviteIdDeclineMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Update the profile information of the currently authenticated user
 * @summary Update profile
 */
export const patchV1Me = (
  patchV1MeBody: MaybeRef<PatchV1MeBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  patchV1MeBody = unref(patchV1MeBody)

  return customInstance<void>(
    {
      url: `/v1/me`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: patchV1MeBody,
    },
    options,
  )
}

export const getPatchV1MeMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchV1Me>>,
    TError,
    { data: BodyType<PatchV1MeBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchV1Me>>,
  TError,
  { data: BodyType<PatchV1MeBody> },
  TContext
> => {
  const mutationKey = ['patchV1Me']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchV1Me>>,
    { data: BodyType<PatchV1MeBody> }
  > = (props) => {
    const { data } = props ?? {}

    return patchV1Me(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PatchV1MeMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1Me>>>
export type PatchV1MeMutationBody = BodyType<PatchV1MeBody>
export type PatchV1MeMutationError = ErrorType<void>

/**
 * @summary Update profile
 */
export const usePatchV1Me = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchV1Me>>,
      TError,
      { data: BodyType<PatchV1MeBody> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof patchV1Me>>,
  TError,
  { data: BodyType<PatchV1MeBody> },
  TContext
> => {
  const mutationOptions = getPatchV1MeMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
