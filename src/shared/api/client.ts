/**
 * Generated by orval v7.12.2 üç∫
 * Do not edit manually.
 * LocalLoop API
 * A marketplace for local microservices and resource exchange
 * OpenAPI spec version: 0.1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/vue-query'
import type {
  DataTag,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryReturnType,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType,
} from '@tanstack/vue-query'

import { unref } from 'vue'
import type { MaybeRef } from 'vue'

import { customInstance } from './mutator/custom-instance'
import type { ErrorType, BodyType } from './mutator/custom-instance'
export interface BodyChangeAvatarMeChangeAvatarPost {
  avatar_file: Blob
}

export interface ErrorDetail {
  loc: string[]
  msg: string
  type: string
}

export interface ErrorResponse {
  detail: string
}

/**
 * Request model for Google OAuth authentication.
 */
export interface GoogleAuthRequest {
  code: string
}

export interface HTTPValidationError {
  detail?: ValidationError[]
}

export interface NotFoundResponse {
  detail?: string
}

/**
 * Request model for linking existing account to Google OAuth.
 */
export interface OAuthLinkRequest {
  email: string
  google_id: string
}

export type OAuthUserResponseAvatarUrl = string | null

/**
 * Response model for OAuth user data.
 */
export interface OAuthUserResponse {
  id: string
  email: string
  name: string
  avatar_url: OAuthUserResponseAvatarUrl
  is_oauth_user: boolean
}

export interface UnauthorizedResponse {
  detail?: string
}

export type UserInfoResponseAvatarUrl = string | null

export type UserInfoResponseUpdatedAt = number | null

export interface UserInfoResponse {
  email: string
  name: string
  avatar_url: UserInfoResponseAvatarUrl
  rating: number
  created_at: number
  updated_at: UserInfoResponseUpdatedAt
}

export interface UserLogin {
  /**
   * @minLength 8
   * @maxLength 254
   */
  email: string
  /**
   * @minLength 8
   * @maxLength 64
   */
  password: string
}

export interface UserLoginResponse {
  message?: string
}

export interface UserPasswordUpdate {
  /**
   * @minLength 8
   * @maxLength 64
   */
  old_password: string
  /**
   * @minLength 8
   * @maxLength 64
   */
  new_password: string
}

export interface UserRegister {
  /**
   * @minLength 8
   * @maxLength 254
   */
  email: string
  /**
   * @minLength 8
   * @maxLength 64
   */
  password: string
  /** @minLength 3 */
  name: string
}

export interface UserRegisterResponse {
  /**
   * @minLength 8
   * @maxLength 254
   */
  email: string
  /** @minLength 3 */
  name: string
}

export interface UserUpdate {
  name: string
}

export type UserUpdateResponseAvatarUrl = string | null

export interface UserUpdateResponse {
  email: string
  name: string
  avatar_url: UserUpdateResponseAvatarUrl
}

export type ValidationErrorLocItem = string | number

export interface ValidationError {
  loc: ValidationErrorLocItem[]
  msg: string
  type: string
}

export interface ValidationErrorResponse {
  detail: ErrorDetail[]
}

export interface VerificationCodeRequest {
  /**
   * @minLength 8
   * @maxLength 254
   */
  email: string
}

export interface VerificationCodeRequestResponse {
  message?: string
}

export interface VerificationCodeVerify {
  /**
   * @minLength 8
   * @maxLength 254
   */
  email: string
  /**
   * @minimum 100000
   * @maximum 999999
   */
  code: number
}

export interface VerificationCodeVerifyResponse {
  message?: string
}

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * @summary Register
 */
export const registerAuthRegisterPost = (
  userRegister: MaybeRef<UserRegister>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  userRegister = unref(userRegister)

  return customInstance<UserRegisterResponse>(
    {
      url: `/auth/register/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: userRegister,
      signal,
    },
    options,
  )
}

export const getRegisterAuthRegisterPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registerAuthRegisterPost>>,
    TError,
    { data: BodyType<UserRegister> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof registerAuthRegisterPost>>,
  TError,
  { data: BodyType<UserRegister> },
  TContext
> => {
  const mutationKey = ['registerAuthRegisterPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof registerAuthRegisterPost>>,
    { data: BodyType<UserRegister> }
  > = (props) => {
    const { data } = props ?? {}

    return registerAuthRegisterPost(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RegisterAuthRegisterPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof registerAuthRegisterPost>>
>
export type RegisterAuthRegisterPostMutationBody = BodyType<UserRegister>
export type RegisterAuthRegisterPostMutationError = ErrorType<HTTPValidationError>

/**
 * @summary Register
 */
export const useRegisterAuthRegisterPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof registerAuthRegisterPost>>,
      TError,
      { data: BodyType<UserRegister> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof registerAuthRegisterPost>>,
  TError,
  { data: BodyType<UserRegister> },
  TContext
> => {
  const mutationOptions = getRegisterAuthRegisterPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Login
 */
export const loginAuthLoginPost = (
  userLogin: MaybeRef<UserLogin>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  userLogin = unref(userLogin)

  return customInstance<UserLoginResponse>(
    {
      url: `/auth/login/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: userLogin,
      signal,
    },
    options,
  )
}

export const getLoginAuthLoginPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof loginAuthLoginPost>>,
    TError,
    { data: BodyType<UserLogin> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof loginAuthLoginPost>>,
  TError,
  { data: BodyType<UserLogin> },
  TContext
> => {
  const mutationKey = ['loginAuthLoginPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof loginAuthLoginPost>>,
    { data: BodyType<UserLogin> }
  > = (props) => {
    const { data } = props ?? {}

    return loginAuthLoginPost(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type LoginAuthLoginPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof loginAuthLoginPost>>
>
export type LoginAuthLoginPostMutationBody = BodyType<UserLogin>
export type LoginAuthLoginPostMutationError = ErrorType<HTTPValidationError>

/**
 * @summary Login
 */
export const useLoginAuthLoginPost = <TError = ErrorType<HTTPValidationError>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof loginAuthLoginPost>>,
      TError,
      { data: BodyType<UserLogin> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof loginAuthLoginPost>>,
  TError,
  { data: BodyType<UserLogin> },
  TContext
> => {
  const mutationOptions = getLoginAuthLoginPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Logout
 */
export const logoutAuthLogoutPost = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({ url: `/auth/logout/`, method: 'POST', signal }, options)
}

export const getLogoutAuthLogoutPostMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logoutAuthLogoutPost>>,
    TError,
    void,
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof logoutAuthLogoutPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['logoutAuthLogoutPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logoutAuthLogoutPost>>,
    void
  > = () => {
    return logoutAuthLogoutPost(requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type LogoutAuthLogoutPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof logoutAuthLogoutPost>>
>

export type LogoutAuthLogoutPostMutationError = ErrorType<unknown>

/**
 * @summary Logout
 */
export const useLogoutAuthLogoutPost = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof logoutAuthLogoutPost>>,
      TError,
      void,
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof logoutAuthLogoutPost>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getLogoutAuthLogoutPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Request Verification Code
 */
export const requestVerificationCodeAuthVerificationCodeRequestPost = (
  verificationCodeRequest: MaybeRef<VerificationCodeRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  verificationCodeRequest = unref(verificationCodeRequest)

  return customInstance<VerificationCodeRequestResponse>(
    {
      url: `/auth/verification-code/request/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: verificationCodeRequest,
      signal,
    },
    options,
  )
}

export const getRequestVerificationCodeAuthVerificationCodeRequestPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestVerificationCodeAuthVerificationCodeRequestPost>>,
    TError,
    { data: BodyType<VerificationCodeRequest> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestVerificationCodeAuthVerificationCodeRequestPost>>,
  TError,
  { data: BodyType<VerificationCodeRequest> },
  TContext
> => {
  const mutationKey = ['requestVerificationCodeAuthVerificationCodeRequestPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestVerificationCodeAuthVerificationCodeRequestPost>>,
    { data: BodyType<VerificationCodeRequest> }
  > = (props) => {
    const { data } = props ?? {}

    return requestVerificationCodeAuthVerificationCodeRequestPost(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RequestVerificationCodeAuthVerificationCodeRequestPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof requestVerificationCodeAuthVerificationCodeRequestPost>>
>
export type RequestVerificationCodeAuthVerificationCodeRequestPostMutationBody =
  BodyType<VerificationCodeRequest>
export type RequestVerificationCodeAuthVerificationCodeRequestPostMutationError =
  ErrorType<HTTPValidationError>

/**
 * @summary Request Verification Code
 */
export const useRequestVerificationCodeAuthVerificationCodeRequestPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestVerificationCodeAuthVerificationCodeRequestPost>>,
      TError,
      { data: BodyType<VerificationCodeRequest> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof requestVerificationCodeAuthVerificationCodeRequestPost>>,
  TError,
  { data: BodyType<VerificationCodeRequest> },
  TContext
> => {
  const mutationOptions =
    getRequestVerificationCodeAuthVerificationCodeRequestPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Verify Verification Code
 */
export const verifyVerificationCodeAuthVerificationCodeVerifyPost = (
  verificationCodeVerify: MaybeRef<VerificationCodeVerify>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  verificationCodeVerify = unref(verificationCodeVerify)

  return customInstance<VerificationCodeVerifyResponse>(
    {
      url: `/auth/verification-code/verify/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: verificationCodeVerify,
      signal,
    },
    options,
  )
}

export const getVerifyVerificationCodeAuthVerificationCodeVerifyPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof verifyVerificationCodeAuthVerificationCodeVerifyPost>>,
    TError,
    { data: BodyType<VerificationCodeVerify> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof verifyVerificationCodeAuthVerificationCodeVerifyPost>>,
  TError,
  { data: BodyType<VerificationCodeVerify> },
  TContext
> => {
  const mutationKey = ['verifyVerificationCodeAuthVerificationCodeVerifyPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof verifyVerificationCodeAuthVerificationCodeVerifyPost>>,
    { data: BodyType<VerificationCodeVerify> }
  > = (props) => {
    const { data } = props ?? {}

    return verifyVerificationCodeAuthVerificationCodeVerifyPost(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type VerifyVerificationCodeAuthVerificationCodeVerifyPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof verifyVerificationCodeAuthVerificationCodeVerifyPost>>
>
export type VerifyVerificationCodeAuthVerificationCodeVerifyPostMutationBody =
  BodyType<VerificationCodeVerify>
export type VerifyVerificationCodeAuthVerificationCodeVerifyPostMutationError =
  ErrorType<HTTPValidationError>

/**
 * @summary Verify Verification Code
 */
export const useVerifyVerificationCodeAuthVerificationCodeVerifyPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof verifyVerificationCodeAuthVerificationCodeVerifyPost>>,
      TError,
      { data: BodyType<VerificationCodeVerify> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof verifyVerificationCodeAuthVerificationCodeVerifyPost>>,
  TError,
  { data: BodyType<VerificationCodeVerify> },
  TContext
> => {
  const mutationOptions =
    getVerifyVerificationCodeAuthVerificationCodeVerifyPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Retrieve the current authenticated user's profile information
 * @summary Get current user profile
 */
export const getRequestUserMeGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UserInfoResponse>({ url: `/me/`, method: 'GET', signal }, options)
}

export const getGetRequestUserMeGetQueryKey = () => {
  return ['me'] as const
}

export const getGetRequestUserMeGetInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getRequestUserMeGet>>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRequestUserMeGet>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetRequestUserMeGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRequestUserMeGet>>> = ({ signal }) =>
    getRequestUserMeGet(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getRequestUserMeGet>>,
    TError,
    TData
  >
}

export type GetRequestUserMeGetInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRequestUserMeGet>>
>
export type GetRequestUserMeGetInfiniteQueryError = ErrorType<
  UnauthorizedResponse | NotFoundResponse
>

/**
 * @summary Get current user profile
 */

export function useGetRequestUserMeGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRequestUserMeGet>>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRequestUserMeGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetRequestUserMeGetInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

export const getGetRequestUserMeGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getRequestUserMeGet>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequestUserMeGet>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetRequestUserMeGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRequestUserMeGet>>> = ({ signal }) =>
    getRequestUserMeGet(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRequestUserMeGet>>,
    TError,
    TData
  >
}

export type GetRequestUserMeGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRequestUserMeGet>>
>
export type GetRequestUserMeGetQueryError = ErrorType<UnauthorizedResponse | NotFoundResponse>

/**
 * @summary Get current user profile
 */

export function useGetRequestUserMeGet<
  TData = Awaited<ReturnType<typeof getRequestUserMeGet>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequestUserMeGet>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetRequestUserMeGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * @summary Update User
 */
export const updateUserMePatch = (
  userUpdate: MaybeRef<UserUpdate>,
  options?: SecondParameter<typeof customInstance>,
) => {
  userUpdate = unref(userUpdate)

  return customInstance<UserUpdateResponse>(
    {
      url: `/me/`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: userUpdate,
    },
    options,
  )
}

export const getUpdateUserMePatchMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUserMePatch>>,
    TError,
    { data: BodyType<UserUpdate> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUserMePatch>>,
  TError,
  { data: BodyType<UserUpdate> },
  TContext
> => {
  const mutationKey = ['updateUserMePatch']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUserMePatch>>,
    { data: BodyType<UserUpdate> }
  > = (props) => {
    const { data } = props ?? {}

    return updateUserMePatch(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateUserMePatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUserMePatch>>
>
export type UpdateUserMePatchMutationBody = BodyType<UserUpdate>
export type UpdateUserMePatchMutationError = ErrorType<HTTPValidationError>

/**
 * @summary Update User
 */
export const useUpdateUserMePatch = <TError = ErrorType<HTTPValidationError>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateUserMePatch>>,
      TError,
      { data: BodyType<UserUpdate> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof updateUserMePatch>>,
  TError,
  { data: BodyType<UserUpdate> },
  TContext
> => {
  const mutationOptions = getUpdateUserMePatchMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Change the current user's password. Requires current password verification.
 * @summary Change user password
 */
export const changePasswordMeChangePasswordPost = (
  userPasswordUpdate: MaybeRef<UserPasswordUpdate>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  userPasswordUpdate = unref(userPasswordUpdate)

  return customInstance<UserUpdateResponse>(
    {
      url: `/me/change-password/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: userPasswordUpdate,
      signal,
    },
    options,
  )
}

export const getChangePasswordMeChangePasswordPostMutationOptions = <
  TError = ErrorType<
    ErrorResponse | UnauthorizedResponse | NotFoundResponse | ValidationErrorResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof changePasswordMeChangePasswordPost>>,
    TError,
    { data: BodyType<UserPasswordUpdate> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof changePasswordMeChangePasswordPost>>,
  TError,
  { data: BodyType<UserPasswordUpdate> },
  TContext
> => {
  const mutationKey = ['changePasswordMeChangePasswordPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePasswordMeChangePasswordPost>>,
    { data: BodyType<UserPasswordUpdate> }
  > = (props) => {
    const { data } = props ?? {}

    return changePasswordMeChangePasswordPost(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ChangePasswordMeChangePasswordPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof changePasswordMeChangePasswordPost>>
>
export type ChangePasswordMeChangePasswordPostMutationBody = BodyType<UserPasswordUpdate>
export type ChangePasswordMeChangePasswordPostMutationError = ErrorType<
  ErrorResponse | UnauthorizedResponse | NotFoundResponse | ValidationErrorResponse
>

/**
 * @summary Change user password
 */
export const useChangePasswordMeChangePasswordPost = <
  TError = ErrorType<
    ErrorResponse | UnauthorizedResponse | NotFoundResponse | ValidationErrorResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof changePasswordMeChangePasswordPost>>,
      TError,
      { data: BodyType<UserPasswordUpdate> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof changePasswordMeChangePasswordPost>>,
  TError,
  { data: BodyType<UserPasswordUpdate> },
  TContext
> => {
  const mutationOptions = getChangePasswordMeChangePasswordPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Change Avatar
 */
export const changeAvatarMeChangeAvatarPost = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UserUpdateResponse>(
    { url: `/me/change-avatar/`, method: 'POST', signal },
    options,
  )
}

export const getChangeAvatarMeChangeAvatarPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof changeAvatarMeChangeAvatarPost>>,
    TError,
    void,
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof changeAvatarMeChangeAvatarPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['changeAvatarMeChangeAvatarPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changeAvatarMeChangeAvatarPost>>,
    void
  > = () => {
    return changeAvatarMeChangeAvatarPost(requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ChangeAvatarMeChangeAvatarPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof changeAvatarMeChangeAvatarPost>>
>

export type ChangeAvatarMeChangeAvatarPostMutationError = ErrorType<HTTPValidationError>

/**
 * @summary Change Avatar
 */
export const useChangeAvatarMeChangeAvatarPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof changeAvatarMeChangeAvatarPost>>,
      TError,
      void,
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof changeAvatarMeChangeAvatarPost>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getChangeAvatarMeChangeAvatarPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Authenticate user via Google OAuth for both web and mobile.
 * @summary Google Oauth
 */
export const googleOauthAuthGooglePost = (
  googleAuthRequest: MaybeRef<GoogleAuthRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  googleAuthRequest = unref(googleAuthRequest)

  return customInstance<OAuthUserResponse>(
    {
      url: `/auth/google`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: googleAuthRequest,
      signal,
    },
    options,
  )
}

export const getGoogleOauthAuthGooglePostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof googleOauthAuthGooglePost>>,
    TError,
    { data: BodyType<GoogleAuthRequest> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof googleOauthAuthGooglePost>>,
  TError,
  { data: BodyType<GoogleAuthRequest> },
  TContext
> => {
  const mutationKey = ['googleOauthAuthGooglePost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof googleOauthAuthGooglePost>>,
    { data: BodyType<GoogleAuthRequest> }
  > = (props) => {
    const { data } = props ?? {}

    return googleOauthAuthGooglePost(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type GoogleOauthAuthGooglePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof googleOauthAuthGooglePost>>
>
export type GoogleOauthAuthGooglePostMutationBody = BodyType<GoogleAuthRequest>
export type GoogleOauthAuthGooglePostMutationError = ErrorType<HTTPValidationError>

/**
 * @summary Google Oauth
 */
export const useGoogleOauthAuthGooglePost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof googleOauthAuthGooglePost>>,
      TError,
      { data: BodyType<GoogleAuthRequest> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof googleOauthAuthGooglePost>>,
  TError,
  { data: BodyType<GoogleAuthRequest> },
  TContext
> => {
  const mutationOptions = getGoogleOauthAuthGooglePostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Link an existing user account to Google OAuth for both web and mobile.
 * @summary Link Account To Google
 */
export const linkAccountToGoogleAuthGoogleLinkPost = (
  oAuthLinkRequest: MaybeRef<OAuthLinkRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  oAuthLinkRequest = unref(oAuthLinkRequest)

  return customInstance<OAuthUserResponse>(
    {
      url: `/auth/google/link`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: oAuthLinkRequest,
      signal,
    },
    options,
  )
}

export const getLinkAccountToGoogleAuthGoogleLinkPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof linkAccountToGoogleAuthGoogleLinkPost>>,
    TError,
    { data: BodyType<OAuthLinkRequest> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof linkAccountToGoogleAuthGoogleLinkPost>>,
  TError,
  { data: BodyType<OAuthLinkRequest> },
  TContext
> => {
  const mutationKey = ['linkAccountToGoogleAuthGoogleLinkPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof linkAccountToGoogleAuthGoogleLinkPost>>,
    { data: BodyType<OAuthLinkRequest> }
  > = (props) => {
    const { data } = props ?? {}

    return linkAccountToGoogleAuthGoogleLinkPost(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type LinkAccountToGoogleAuthGoogleLinkPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof linkAccountToGoogleAuthGoogleLinkPost>>
>
export type LinkAccountToGoogleAuthGoogleLinkPostMutationBody = BodyType<OAuthLinkRequest>
export type LinkAccountToGoogleAuthGoogleLinkPostMutationError = ErrorType<HTTPValidationError>

/**
 * @summary Link Account To Google
 */
export const useLinkAccountToGoogleAuthGoogleLinkPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof linkAccountToGoogleAuthGoogleLinkPost>>,
      TError,
      { data: BodyType<OAuthLinkRequest> },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof linkAccountToGoogleAuthGoogleLinkPost>>,
  TError,
  { data: BodyType<OAuthLinkRequest> },
  TContext
> => {
  const mutationOptions = getLinkAccountToGoogleAuthGoogleLinkPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get Google OAuth authorization URL.
 * @summary Get Google Auth Url
 */
export const getGoogleAuthUrlAuthGoogleUrlGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({ url: `/auth/google/url`, method: 'GET', signal }, options)
}

export const getGetGoogleAuthUrlAuthGoogleUrlGetQueryKey = () => {
  return ['auth', 'google', 'url'] as const
}

export const getGetGoogleAuthUrlAuthGoogleUrlGetInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getGoogleAuthUrlAuthGoogleUrlGet>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getGoogleAuthUrlAuthGoogleUrlGet>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetGoogleAuthUrlAuthGoogleUrlGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGoogleAuthUrlAuthGoogleUrlGet>>> = ({
    signal,
  }) => getGoogleAuthUrlAuthGoogleUrlGet(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getGoogleAuthUrlAuthGoogleUrlGet>>,
    TError,
    TData
  >
}

export type GetGoogleAuthUrlAuthGoogleUrlGetInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGoogleAuthUrlAuthGoogleUrlGet>>
>
export type GetGoogleAuthUrlAuthGoogleUrlGetInfiniteQueryError = ErrorType<unknown>

/**
 * @summary Get Google Auth Url
 */

export function useGetGoogleAuthUrlAuthGoogleUrlGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGoogleAuthUrlAuthGoogleUrlGet>>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGoogleAuthUrlAuthGoogleUrlGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGoogleAuthUrlAuthGoogleUrlGetInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

export const getGetGoogleAuthUrlAuthGoogleUrlGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getGoogleAuthUrlAuthGoogleUrlGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getGoogleAuthUrlAuthGoogleUrlGet>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getGetGoogleAuthUrlAuthGoogleUrlGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGoogleAuthUrlAuthGoogleUrlGet>>> = ({
    signal,
  }) => getGoogleAuthUrlAuthGoogleUrlGet(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGoogleAuthUrlAuthGoogleUrlGet>>,
    TError,
    TData
  >
}

export type GetGoogleAuthUrlAuthGoogleUrlGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGoogleAuthUrlAuthGoogleUrlGet>>
>
export type GetGoogleAuthUrlAuthGoogleUrlGetQueryError = ErrorType<unknown>

/**
 * @summary Get Google Auth Url
 */

export function useGetGoogleAuthUrlAuthGoogleUrlGet<
  TData = Awaited<ReturnType<typeof getGoogleAuthUrlAuthGoogleUrlGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGoogleAuthUrlAuthGoogleUrlGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGoogleAuthUrlAuthGoogleUrlGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * @summary Health Check
 */
export const healthCheckGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({ url: `/`, method: 'GET', signal }, options)
}

export const getHealthCheckGetQueryKey = () => {
  return [] as const
}

export const getHealthCheckGetInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof healthCheckGet>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheckGet>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getHealthCheckGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckGet>>> = ({ signal }) =>
    healthCheckGet(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof healthCheckGet>>,
    TError,
    TData
  >
}

export type HealthCheckGetInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheckGet>>
>
export type HealthCheckGetInfiniteQueryError = ErrorType<unknown>

/**
 * @summary Health Check
 */

export function useHealthCheckGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthCheckGet>>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheckGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getHealthCheckGetInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

export const getHealthCheckGetQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheckGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckGet>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = getHealthCheckGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckGet>>> = ({ signal }) =>
    healthCheckGet(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheckGet>>,
    TError,
    TData
  >
}

export type HealthCheckGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckGet>>>
export type HealthCheckGetQueryError = ErrorType<unknown>

/**
 * @summary Health Check
 */

export function useHealthCheckGet<
  TData = Awaited<ReturnType<typeof healthCheckGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckGet>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getHealthCheckGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}
